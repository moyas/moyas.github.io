<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[是时候规范一下Markdown文本的书写了]]></title>
      <url>%2F2016%2F11%2F27%2FMarkdown%E8%A7%84%E8%8C%83%2F</url>
      <content type="text"><![CDATA[说明Markdowm 介绍轻量级标记语言（html、xml），2004 年被 John Gruber 创造，它允许人们“使用易读易写的纯文本格式编写文档”，Markdown 最重要的设计就是可读性， Markdown 可以选择性的转换为 HTML 文档格式，很多网站目前都使用了 Markdown 或者其变种，例如Github、简书等大型社区。 Markdown 的优点 纯文本，所以兼容性极强，可以用所有文本编辑器打开 专注于文字写作而不是排版 格式转换方便，可以轻松转换为 HTML、PPT、电子书等 Markdown 标记语法简单好记，可读性强 安装和配置编写预览环境webstormVisual Studio Code 基本语法段落轻量级标记语言.不会换行连续写的话两个空格 再换行就是换行(这个就是空格加换行实现的) 再起一个段落就是中间保持换行 加粗加粗的字体 使用** +文字+ **实现字体的加粗 斜体倾斜的字体 使用* +文字+ *实现字体的加粗 列表无序列表 Markdowm 是一个轻量级的标记语言 一级列表建议用 - 号 二级列表建议用 + 号 三级列表建议使用 * 号 轻量级 高效 有序列表 有序列表直接用序列加 . 然后加空格写内容 二级有序列表 有序列表嵌套无序列表 换行接着写 - 添加无序列表 有序列表嵌套无序列表 三级有序列表 有序嵌套有序列表 换行 加有序列表 第二个 使用建议无论是有序的还是无序的列表如果写一些一级的列表,没什么嵌套就紧凑的写在一起,有过有多个嵌套,就在列表和列表之间加换行 链接请点击查看孙琦github 实现方式: [内容](链接地址) 图片 实现方式:![描述](地址 可以是本地地址和网络图片链接) 文本引用 床前明月光 实现方式: &gt; + 文本 行内代码高亮例如:在javascript中我们可以用 val 定义变量 实现方式: 在行内添加 `` 行内代码高亮和多行代码高亮123456function createRequest()&#123; return window.XMLHttpRequest ? new window.XMLHttpRequest() :new ActiveXObject('Microsoft.XMLHTTP'); &#125;; var xhr = createRequest(); console.log(xhr); 原样展示文本1文本内容 表格 编号 姓名 年龄 01 sunqi 18 02 moyas 20 Markdowm 的使用场景 学习笔记 演讲稿 演讲：以后都做一个PPT或者写一个 Markdown 演讲稿 写书（侧重于技术相关的内容非常适合） 个人笔记 文章博客 教学讲义 说明文档 电子邮件 只要有写作的地方，都可以使用 Markdown 来书写。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[javascript原生框架(七)--动画模块]]></title>
      <url>%2F2016%2F11%2F25%2Fjs%E5%8E%9F%E7%94%9F%E6%A1%86%E6%9E%B6-%E5%8A%A8%E7%94%BB%E6%A8%A1%E5%9D%97%2F</url>
      <content type="text"><![CDATA[匀速直线动画 固定时间 固定距离 如何判定动画结束的时机？ 使用时间来判断是否结束动画。 如果动画时间到达了 指定的时间，那么就结束动画，并且让动画元素到达终点 实现思路 定义动画函数，animate函数。当调用animate函数时，即动画开始的时间 定义render函数，用来给动画元素设置 属性值 计算当前动画元素所在的位置，然后累计到其对应属性值上。 首先计算动画的时间间隔 如果时间间隔大于或等于指定的总时间，那么就停止动画并设置动画元素到达终点 否则，根据速度，动画时间间隔计算出位移。在将其与起始位置累加后赋值给elem 定义定时器，开始动画 匀减速直线动画 物理公式 a: 加速度 t： 时间间隔 v0：初始速度 vt：末速度 S： 位移 正方向：S = v0 t + a t * t / 2; 末速度：vt = v0 + at S ==&gt; target - location t ==&gt; duration v0 = 0 正方向 a = 2 ( S - v0 t) / ( t * t) ==&gt; = 2 * S / ( t * t ) ==&gt; = 2 * (target - location) /( duration * duration) vt = 2 * (target - location) / duration time时间间隔内的 匀减速位移tween = v0 time - a time time / 2 ==&gt; tween = 2 distance * time / duration - distance * time * time /( duration * duration) 动画的基本结构123456function animate() &#123; function render() &#123; &#125; window.setInterval(render, time);&#125; animate动画的封装代码(曲线代码不是自己写的,哈哈)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242// 动画模块 var easing = &#123; linear: function(x, t, b, c, d) &#123; return (c - b) * t / d; &#125;, minusspeed: function(x, t, b, c, d) &#123; return 2 * (c - b) * t / d - (c - b) * t * t / (d * d); &#125;, easeInQuad: function(x, t, b, c, d) &#123; return c * (t /= d) * t + b; &#125;, easeOutQuad: function(x, t, b, c, d) &#123; return -c * (t /= d) * (t - 2) + b; &#125;, easeInOutQuad: function(x, t, b, c, d) &#123; if ((t /= d / 2) &lt; 1) return c / 2 * t * t + b; return -c / 2 * ((--t) * (t - 2) - 1) + b; &#125;, easeInCubic: function(x, t, b, c, d) &#123; return c * (t /= d) * t * t + b; &#125;, easeOutCubic: function(x, t, b, c, d) &#123; return c * ((t = t / d - 1) * t * t + 1) + b; &#125;, easeInOutCubic: function(x, t, b, c, d) &#123; if ((t /= d / 2) &lt; 1) return c / 2 * t * t * t + b; return c / 2 * ((t -= 2) * t * t + 2) + b; &#125;, easeInQuart: function(x, t, b, c, d) &#123; return c * (t /= d) * t * t * t + b; &#125;, easeOutQuart: function(x, t, b, c, d) &#123; return -c * ((t = t / d - 1) * t * t * t - 1) + b; &#125;, easeInOutQuart: function(x, t, b, c, d) &#123; if ((t /= d / 2) &lt; 1) return c / 2 * t * t * t * t + b; return -c / 2 * ((t -= 2) * t * t * t - 2) + b; &#125;, easeInQuint: function(x, t, b, c, d) &#123; return c * (t /= d) * t * t * t * t + b; &#125;, easeOutQuint: function(x, t, b, c, d) &#123; return c * ((t = t / d - 1) * t * t * t * t + 1) + b; &#125;, easeInOutQuint: function(x, t, b, c, d) &#123; if ((t /= d / 2) &lt; 1) return c / 2 * t * t * t * t * t + b; return c / 2 * ((t -= 2) * t * t * t * t + 2) + b; &#125;, easeInSine: function(x, t, b, c, d) &#123; return -c * Math.cos(t / d * (Math.PI / 2)) + c + b; &#125;, easeOutSine: function(x, t, b, c, d) &#123; return c * Math.sin(t / d * (Math.PI / 2)) + b; &#125;, easeInOutSine: function(x, t, b, c, d) &#123; return -c / 2 * (Math.cos(Math.PI * t / d) - 1) + b; &#125;, easeInExpo: function(x, t, b, c, d) &#123; return (t == 0) ? b : c * Math.pow(2, 10 * (t / d - 1)) + b; &#125;, easeOutExpo: function(x, t, b, c, d) &#123; return (t == d) ? b + c : c * (-Math.pow(2, -10 * t / d) + 1) + b; &#125;, easeInOutExpo: function(x, t, b, c, d) &#123; if (t == 0) return b; if (t == d) return b + c; if ((t /= d / 2) &lt; 1) return c / 2 * Math.pow(2, 10 * (t - 1)) + b; return c / 2 * (-Math.pow(2, -10 * --t) + 2) + b; &#125;, easeInCirc: function(x, t, b, c, d) &#123; return -c * (Math.sqrt(1 - (t /= d) * t) - 1) + b; &#125;, easeOutCirc: function(x, t, b, c, d) &#123; return c * Math.sqrt(1 - (t = t / d - 1) * t) + b; &#125;, easeInOutCirc: function(x, t, b, c, d) &#123; if ((t /= d / 2) &lt; 1) return -c / 2 * (Math.sqrt(1 - t * t) - 1) + b; return c / 2 * (Math.sqrt(1 - (t -= 2) * t) + 1) + b; &#125;, easeInElastic: function(x, t, b, c, d) &#123; var s = 1.70158; var p = 0; var a = c; if (t == 0) return b; if ((t /= d) == 1) return b + c; if (!p) p = d * .3; if (a &lt; Math.abs(c)) &#123; a = c; var s = p / 4; &#125; else var s = p / (2 * Math.PI) * Math.asin(c / a); return -(a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p)) + b; &#125;, easeOutElastic: function(x, t, b, c, d) &#123; var s = 1.70158; var p = 0; var a = c; if (t == 0) return b; if ((t /= d) == 1) return b + c; if (!p) p = d * .3; if (a &lt; Math.abs(c)) &#123; a = c; var s = p / 4; &#125; else var s = p / (2 * Math.PI) * Math.asin(c / a); return a * Math.pow(2, -10 * t) * Math.sin((t * d - s) * (2 * Math.PI) / p) + c + b; &#125;, easeInOutElastic: function(x, t, b, c, d) &#123; var s = 1.70158; var p = 0; var a = c; if (t == 0) return b; if ((t /= d / 2) == 2) return b + c; if (!p) p = d * (.3 * 1.5); if (a &lt; Math.abs(c)) &#123; a = c; var s = p / 4; &#125; else var s = p / (2 * Math.PI) * Math.asin(c / a); if (t &lt; 1) return -.5 * (a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p)) + b; return a * Math.pow(2, -10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p) * .5 + c + b; &#125;, easeInBack: function(x, t, b, c, d, s) &#123; if (s == undefined) s = 1.70158; return c * (t /= d) * t * ((s + 1) * t - s) + b; &#125;, easeOutBack: function(x, t, b, c, d, s) &#123; if (s == undefined) s = 1.70158; return c * ((t = t / d - 1) * t * ((s + 1) * t + s) + 1) + b; &#125;, easeInOutBack: function(x, t, b, c, d, s) &#123; if (s == undefined) s = 1.70158; if ((t /= d / 2) &lt; 1) return c / 2 * (t * t * (((s *= (1.525)) + 1) * t - s)) + b; return c / 2 * ((t -= 2) * t * (((s *= (1.525)) + 1) * t + s) + 2) + b; &#125;, easeOutBounce: function(x, t, b, c, d) &#123; if ((t /= d) &lt; (1 / 2.75)) &#123; return c * (7.5625 * t * t) + b; &#125; else if (t &lt; (2 / 2.75)) &#123; return c * (7.5625 * (t -= (1.5 / 2.75)) * t + .75) + b; &#125; else if (t &lt; (2.5 / 2.75)) &#123; return c * (7.5625 * (t -= (2.25 / 2.75)) * t + .9375) + b; &#125; else &#123; return c * (7.5625 * (t -= (2.625 / 2.75)) * t + .984375) + b; &#125; &#125; &#125;; // 获取所有动画属性的起始值 var kv = &#123; 'left': 'offsetLeft', 'top': 'offsetTop', 'width': 'offsetWidth', 'height': 'offsetHeight' &#125;; function getLocation(elem, target) &#123; var obj = &#123;&#125;; for (var k in target) &#123; obj[k] = elem[kv[k]]; &#125; return obj; &#125; function getDistance(location, target) &#123; var obj = &#123;&#125;; for (var k in target) &#123; obj[k] = parseFloat(target[k]) - location[k]; &#125; return obj; &#125; function getTween(time, location, target, duration, easingName) &#123; var obj = &#123;&#125;; for (var k in target) &#123; obj[k] = easing[easingName](null, time, location[k], target[k], duration); &#125; return obj; &#125; function setStyles(elem, location, tween) &#123; var k; for (k in location) &#123; elem.style[k] = location[k] + tween[k] + 'px'; &#125; &#125; var animate = function(elem, target, duration, easingName) &#123; var timer, // 定时器id tween, // 单位时间间隔的位移&#123;left: 800, top:400&#125; location, // 起始位置&#123;left: 8,top: 8&#125; distance, // 动画总距离&#123;left: 992, top: 792&#125; startTime, // 动画开始时间 currentTime, // 动画当前时间 time; // 当前动画经过总时间间隔 location = getLocation(elem, target); distance = getDistance(location, target); startTime = +new Date; // 转换毫秒值 // 用来计算动画当前位移，并制定动画元素的位置 var render = function() &#123; currentTime = +new Date; time = currentTime - startTime; // 如果当前动画经过总时间间隔大于或等于 指定总时间 // 停止动画,并设置动画元素到达终点 if (time &gt;= duration) &#123; // console.log(time); // 1 设置动画元素到达终点 tween = distance; // 2 停止动画，即清楚定时器 global.clearInterval(timer); // 3 删除动画元素的timerId属性 delete elem.timerId; &#125; else &#123; // 否则, 根据匀减速运动公式来求time时间间隔内的位移 // 指定动画元素的位置 // 注意： 要加上 起始位置 tween = getTween(time, location, target, duration, easingName); &#125; // 设置动画属性值 setStyles(elem, location, tween); &#125;; // 启动定时器 开始动画 timer = global.setInterval(render, 1000 / 60); // 把定时器id存储在动画元素上（以自定义属性） elem.timerId = timer; &#125;; moyas.fn.extend(&#123; animate: function(target, duration, easingName) &#123; easingName = easingName || 'linear'; return this.each(function() &#123; if(!('timerId' in this))&#123; animate(this, target, duration, easingName); &#125; &#125;); &#125;, stop: function() &#123; return this.each(function() &#123; if('timerId' in this)&#123; global.clearInterval(this.timerId); delete this.timerId; &#125; &#125;); &#125; &#125;);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[javascript原生框架(六)--事件处理]]></title>
      <url>%2F2016%2F11%2F23%2Fjs%E5%8E%9F%E7%94%9F%E6%A1%86%E6%9E%B6-%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%2F</url>
      <content type="text"><![CDATA[事件绑定 DOM0方式 通过dom元素的（on + 事件名称）属性来绑定事件，并且赋值为 一个字符串 上述字符串为 执行该事件的代码块（逻辑） 缺点: 可读性 以及 可维护性不好。 DOM0方式的加强版 通过dom元素的（on + 事件名称）属性来绑定事件，并且赋值为 事件处理函数 缺点: 定义很多的全局函数，容易造成内存过大损耗。依然没有解决js代码 和 html的耦合度问题 IE标准： 通过attachEvent方法来绑定事件 语法：dom.attachEvent(type, callback) 移除事件：detachEvent(type, callback) 注意：如果想要删除某个事件的处理函数，不能将该处理函数定义为匿名的 W3C标准 通过addEventListener方法来给dom元素绑定事件 语法: dom.addEventListener(type, callback, useCapture) useCapture默认值为 false 移除事件：removeEventListener(type, callback) 注意：如果想要删除某个事件的处理函数，不能将该处理函数定义为匿名的 事件流 概念：用户在触发某一动作时，页面所做相关反映的过程。 三个阶段： 事件捕获阶段 处于事件源阶段 冒泡阶段 事件流种类： 捕获型事件流: 事件处理函数 是在 事件的捕获阶段执行 冒泡型事件流：事件处理函数 是在 事件的冒泡阶段执行 attachEvent 和 addEventListener 区别 参数个数不同 事件类型 传值也不同 IE：要+ ‘on’前缀 W3C：不需要 在绑定多个事件处理函数时，IE在执行处理函数时，顺序不定（得看版本）；而W3C，按照队列结构来依次执行事件的处理函数 在事件处理函数内this指向不同 IE: window w3c: 返回正在执行事件处理函数的 dom元素 addEvent方法 根据浏览器能力，提前返回 事件绑定方法 如果浏览器符合W3C标准，使用addEventListener绑定事件 否则就使用attachEvent来绑定事件 removeEvent方法 根据浏览器能力，提前返回 事件移除方法 如果浏览器符合W3C标准，使用removeEventListener移除事件处理函数 否则就使用detachEvent来移除事件处理函数 on方法 功能：给moyas对象上所有dom元素绑定事件 实现思路 遍历this上所有dom元素 调用addEvent给当前遍历到的dom元素绑定事件 返回this，实现链式编程 off方法 功能：移除moyas对象上所有dom元素的事件处理函数 实现思路 遍历this上所有dom元素 调用removeEvent给当前遍历到的dom元素移除相应事件的处理函数 返回this，实现链式编程 代码如下123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// 提前返回 var addEvent = function() &#123; // 如果符合W3C标准，使用addEvnetListener绑定事件 if (global.addEventListener) &#123; return function(elem, type, callback, useCapture) &#123; elem.addEventListener(type, callback, useCapture || false); &#125;; &#125; else &#123; // 否则就使用IE标准的 attachEvent绑定事件 return function(elem, type, callback) &#123; elem.attachEvent('on' + type, callback); &#125;; &#125; &#125;(); //todo待解决问题 //addEventListenter 中的this 指向 事件的触发者 //attachEvlent 中的this 指向 window 对象 var removeEvent = function() &#123; if (global.removeEventListener) &#123; return function(elem, type, callback) &#123; elem.removeEventListener(type, callback); &#125;; &#125; else &#123; return function(elem, type, callback) &#123; elem.detachEvent('on' + type, callback); &#125;; &#125; &#125;(); // 事件模块 moyas.fn.extend(&#123; on: function(type, callback, capture) &#123; return this.each(function() &#123; addEvent(this, type, callback, capture); &#125;); &#125;, off: function(type, callback) &#123; return this.each(function() &#123; removeEvent(this, type, callback); &#125;); &#125; &#125;); moyas.each(['click', 'dblclick', 'keypress', 'keyup', 'keydown', 'mouseover', 'mouseout', 'mouseenter', 'mouseleave', 'mousemove', 'mouseup', 'mousedown'], function(type) &#123; moyas.fn[type] = function(callback, capture) &#123; return this.on(type, callback, capture); &#125;; &#125;);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[javascript原生框架(五)--文档处理模块]]></title>
      <url>%2F2016%2F11%2F22%2Fjs%E5%8E%9F%E7%94%9F%E6%A1%86%E6%9E%B6-%E6%96%87%E6%A1%A3%E5%A4%84%E7%90%86%2F</url>
      <content type="text"><![CDATA[appendTo方法 语法：.appendTo(target) target类型 选择器、dom元素、dom数组 统一target类型 为 moyas对象：为了方便操作 实现思路 统一target类型，定义新增节点变量node，临时存储要分配的节点 定义ret数组变量，用来存储总共分配出去的节点 遍历this上的每一个dom元素，在遍历target上的每一个dom元素 首先判断当前dom元素是否为target上的第一个dom元素 如果为真，就不克隆节点，直接将要被添加的节点赋值给node 如果为假，就要深克隆节点，在赋值给node 使用遍历target当前的dom元素 追加 指定节点node 两层循环结束，操作完成。 最后将ret转换成moyas对象，作为appendTo方法的返回值。实现链式编程 append方法 语法：.append(source); 功能：将source上的所有dom元素 追加到 moyas对象 上 实现思路 统一source类型，为moyas对象。 source.appendTo(this) return this; prependTo方法 语法：.prependTo(target); 功能：将moyas对象上的每一个dom元素 追加到 target 最前边 insertBefore 实现思路 统一target类型， 为 moyas对象 定义node变量，临时存储被追加的节点。定义ret数组，存储所有被追加的节点 先遍历target上的每一个dom元素， 定义变量firstChild，临时存储当前目标dom元素的第一个子节点，在遍历this上每一个dom元素 判断当前遍历的dom是否为target上的第一个dom元素 如果为真，此时不需要克隆节点 否则，要深克隆节点 将上述得到的节点，push到ret内 调用insertBefore方法 追加 节点，此时第一个参数为追加新的节点，第二个参数为 firstChild 在 firstChild 之前追加 新节点。 两层循环结束，操作完成 将ret转换成moyas对象，作为prependTo方法的返回值。实现链式编程。 prepend方法 语法：.prepend(source); 功能：把source上的所有的dom元素，添加到this上的最前边 实现思路： 统一source类型，为moyas对象 通过source调用prependTo方法，将source上的所有dom添加到this上的最前边 return this实现链式编程 next方法 功能：获取moyas对象上所有dom元素的下一个兄弟元素（nextSibling） 语法：.next(); 返回值类型：moyas对象 实现思路 定义ret数组，存储所有dom的下一个兄弟元素 遍历this上的所有dom元素 遍历当前dom元素下面的所有兄弟，如果类型为 元素，将此元素存储ret内，结束循环。 两层循环结束，将ret转换成moyas对象，作为next方法的返回值。 nextAll方法 功能：获取moyas对象上所有dom元素下面的所有兄弟元素（nextSibling） 语法：.nextAll(); 返回值类型：moyas对象 实现思路 定义ret数组，存储所有dom下面的所有兄弟元素 遍历this上的所有dom元素 遍历当前dom元素下面的所有兄弟节点，如果类型为 元素，将此元素存储ret内。 两层循环结束，将ret去重后，转换成moyas对象，作为nextAll方法的返回值。 before方法 功能： 语法: .before(source) 实现思路 统一source类型为 moyas对象 遍历this上的每一个dom元素 在遍历source上的每一个dom元素 判断当前遍历this的dom元素的 索引是否为0 如果为0，不需要拷节点 否则要深拷贝节点 先拿到当前遍历this的dom元素的父节点，调用insertBefore方法在其前面添加上面得到的新节点 两层循环完毕，操作完成 return this实现链式编程 after方法（选做） 功能： 语法: .after(source) 实现思路 定义nextSibling变量，存储dom元素的下一个兄弟节点 统一source类型为 moyas对象 遍历this上的每一个dom元素 在遍历source上的每一个dom元素 判断当前遍历this的dom元素的 索引是否为0 如果为0，不需要拷节点 否则要深拷贝节点 先拿到当前遍历this的dom元素的父节点，调用insertBefore方法在nextSibling前面添加上面得到的新节点 两层循环完毕，操作完成 return this实现链式编程 remove方法 功能：将筛选出来的所有dom元素 删除掉 实现思路 遍历this上的所有dom元素 获取当前dom元素的父节点，调用removeChild方法删除自己 循环结束，返回this。 empty方法 功能：将筛选出来的所有dom元素 清空后代节点。 实现思路 遍历this上的所有dom元素 直接给当前dom元素的innerHTML属性赋值为 空字符串 循环结束，返回this， 实现链式编程。 prev方法prevAll方法moyas.unique方法 功能：实现数组元素去重 语法：var newRet = moyas.unique(arr); 实现思路 定义空数组对象ret。存储去重后元素 遍历原数组，如果当前遍历到的元素在ret中不存在，就添加到ret内 循环结束，ret存储的就是去重后的元素 返回ret 兼容IE8 indexOf方法 首先判断当前浏览器是否支持indexOf方法 如果不支持，就给数组对象的原型添加 indexOf方法 遍历this上的所有元素 如果遍历到的当前元素 和 指定参数值 相同，就直接返回其 索引值。结束循环 如果在整个上述循环都没有返回值，那么表示不存在指定参数值，就返回 -1。 详细代码12345678910111213141516171819202122232425262728293031 moyas.extend(&#123; unique: function(arr) &#123; // 存储去重后的结果 var ret = []; // 遍历原数组arr moyas.each(arr, function() &#123; // 判断ret是否存在当前遍历到的元素 // 如果不存在将其添加到ret中 if(ret.indexOf(this) === -1) ret.push(this); &#125;); // 将ret返回 return ret; &#125;&#125;);// 兼容数组对象的indexOf方法 (function() &#123; // 如果浏览器不支持indexOf方法 // 那么就给数组对象的原型添加indexOf方法 if(!Array.prototype.indexOf)&#123; Array.prototype.indexOf = function(val) &#123; // 遍历this for(var i = 0,l = this.length; i &lt; l; i++)&#123; // 如果遍历到的当前元素和val相同，返回其索引值 if(this[i] == val) return i; &#125; // 表示具有指定val元素，返回 -1 return -1; &#125;; &#125; &#125;()); 具体方法代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170moyas.extend(&#123; unique: function(arr) &#123; // 存储去重后的结果 var ret = []; // 遍历原数组arr moyas.each(arr, function() &#123; // 判断ret是否存在当前遍历到的元素 // 如果不存在将其添加到ret中 if(ret.indexOf(this) === -1) ret.push(this); &#125;); // 将ret返回 return ret; &#125; &#125;); moyas.fn.extend(&#123; appendTo: function(target) &#123; var node, ret = []; // 统一target类型 为moyas对象（为了方便操作） target = moyas(target); // 遍历this上的每一个dom元素 this.each(function(v) &#123; // 在遍历目标dom元素 target.each(function(t, i) &#123; // 如果当前dom元素为 目标上的第一个.不拷贝节点 // 否则拷贝节点 node = i === 0 ? v : v.cloneNode(true); // 将被追加的节点,添加到ret内 ret.push(node); // 将节点追加到指定的目标dom元素上. t.appendChild(node); &#125;); &#125;); // 将每一个添加的dom元素,转换成moyas对象返回,实现链式编程 // 原因:在添加样式时,如果不这样做的话,只会给没克隆的节点添加样式. return moyas(ret); &#125;, append: function(source) &#123; source = moyas(source); source.appendTo(this); return this; &#125;, prependTo: function(target) &#123; var node, firstChild, self = this, ret = []; target = moyas(target); // 遍历target上的每一个目标dom元素 target.each(function(elem, i) &#123; // 缓存当前目标dom元素的第一个子节点 firstChild = elem.firstChild; // 在遍历this上的每一个dom元素 self.each(function(dom) &#123; // 判断是否目标上第一个dom元素 // 如果是，不需要克隆节点 // 否则需要深克节点 // 将得到的节点赋值给node node = i === 0 ? dom : dom.cloneNode(true); // 将上面得到的节点添加到ret中 ret.push(node); // 使用insertBefor给当前目标元素，在firstChild添加node节点 elem.insertBefore(node, firstChild); &#125;); &#125;); return moyas(ret); &#125;, prepend: function(source) &#123; source = moyas(source); source.prependTo(this); return this; &#125;, next: function() &#123; // 存储所用dom的下一个兄弟元素 var ret = []; // 遍历this上的所有dom元素 this.each(function() &#123; // 在遍历当前dom元素下面所有的兄弟元素 for(var node = this.nextSibling; node ; node = node.nextSibling)&#123; // 如果当前兄弟节点,为元素节点 // 即为结果,将其添加ret内,并结束循环 if(node.nodeType === 1)&#123; ret.push(node); break; &#125; &#125; &#125;); // 将ret转换成moyas对象,返回 return moyas(ret); &#125;, nextAll: function() &#123; var ret = [], node; this.each(function() &#123; for(node = this.nextSibling; node ; node = node.nextSibling)&#123; if(node.nodeType === 1) ret.push(node); &#125; &#125;); return moyas(moyas.unique(ret)); &#125;, before: function(source) &#123; var node; source = moyas(source); this.each(function(dom, i) &#123; source.each(function(elem) &#123; node = i === 0 ? elem : elem.cloneNode(true); // 获取dom的父节点，调用insertBefore方法在dom前添加新的子节点node dom.parentNode.insertBefore(node, dom); &#125;); &#125;); return this; &#125;, after: function(source) &#123; var node, nextSibling; source = moyas(source); this.each(function(dom, i) &#123; nextSibling = dom.nextSibling; source.each(function(elem) &#123; node = i === 0 ? elem : elem.cloneNode(true); // 获取dom的父节点，调用insertBefore方法在dom前添加新的子节点node dom.parentNode.insertBefore(node, nextSibling); &#125;); &#125;); return this; &#125;, remove:function () &#123; return this.each(function () &#123; this.parentNode.removeChild(this); &#125;); &#125;, prev:function () &#123; var ret=[], node; this.each(function () &#123; for (node = this.previousSibling;node;node=node.previousSibling)&#123; if (node.nodeType === 1)&#123; ret.push(node); break; &#125; &#125; &#125;); return itcast(ret); &#125;, prevAll:function () &#123; var ret=[], node; this.each(function () &#123; for (node = this.previousSibling;node;node=node.previousSibling)&#123; if (node.nodeType === 1)&#123; ret.push(node); &#125; &#125; &#125;); return itcast(itcast.unique(ret)); &#125;, empty:function () &#123; return this.each(function () &#123; this.innerHTML=''; &#125;) &#125; &#125;);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[javascript原生框架(四)--属性模块]]></title>
      <url>%2F2016%2F11%2F20%2Fjs%E5%8E%9F%E7%94%9F%E6%A1%86%E6%9E%B6-%E5%B1%9E%E6%80%A7%E6%A8%A1%E5%9D%97%2F</url>
      <content type="text"><![CDATA[1.attr方法2.html方法3.text方法4.val方法5.prop方法 attr方法：（setAttribute 和 getAttribute） 功能：获取（设置）属性节点值 实现思路 给原型添加attr方法，定义两个参数：属性节点名字name 以及 属性节点值 如果只传入一个参数 如果参数类型为对象，表示设置多个属性节点值 否则，获取指定的属性节点值（默认获取第一个dom元素的属性节点值） 如果传入两个参数，表示设置单个属性节点值。 html方法： 功能: 不传入参数，表示 获取指定dom元素的innerHTML属性自 否则，表示 设置指定dom元素的innerHTML属性 实现思路 判断 是否传入参数 如果没传，获取moyas对象上第一个dom元素的innerHTML属性值 否则, 给moyas对象上每一个dom元素设置innerHTML属性。 text方法 功能： 不传值，表示获取文本节点（返回的是后代中所有文本节点值） 否则，设置指定dom元素文本节点值 实现思路 如果不传值，优先考虑浏览器是否支持textContent属性， 如果支持，就使用textContent返回结果集中每一个dom元素的文本节点值。 否则，就使用innerText 返回结果集中每一个dom元素的文本节点值。 如果传值，给moyas对象上的每一个dom元素设置文本节点值。 如果支持textContent属性，就使用该属性设置文本 否则，就使用innerText来设置文本。 val方法 功能：value属性 如果不传值，表示获取输入框的文本值 如果传值，表示给输入框 设置文本 实现思路 如果不传值，表示获取输入框的文本值（获取第一个文本框值） 如果传值，表示给输入框 设置文本 遍历每一个输入框，同时给其设置文本 prop方法 功能：和attr相似 注意：有些属性名称，比如for，class是保留字或关键字不能作为对象属性名称。 所以要创建一个对象，转换这类的属性 定义propFix对象，存储上述属性 到 新属性名称的 映射关系 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124// 属性模块 moyas.propFix = &#123; 'for': 'htmlFor', 'class': 'className' &#125;; moyas.each([ "tabIndex", "readOnly", "maxLength", "cellSpacing", "cellPadding", "rowSpan", "colSpan", "useMap", "frameBorder", "contentEditable" ], function() &#123; moyas.propFix[this.toLowerCase()] = this; &#125;); console.log(moyas.propFix); moyas.fn.extend(&#123; attr: function(name, value) &#123; // 只传入一个参数 if (value == undefined) &#123; // 如果类型为 对象，表示设置多个属性 if (typeof name === 'object') &#123; // 遍历moyas上的每一个dom元素，并设置属性节点值 this.each(function(v) &#123; // 枚举name对象上每一个属性 for (var k in name) &#123; v.setAttribute(k, name[k]); &#125; &#125;); &#125; else &#123; // 如果类型为 字符串，获取属性节点值 if (!this[0]) return null; return this[0].getAttribute(name); &#125; &#125; else &#123; // 传入两个参数，表示设置单个属性节点值 this.each(function(v) &#123; v.setAttribute(name, value); &#125;); &#125; // 实现链式编程 return this; &#125;, html: function(html) &#123; // 如果没有给html传入值，表示获取 if (html == undefined) &#123; // 如果moyas对象没有任何dom元素，就返回一个期望值 即空字符串 // 如果有的话，就返回第一个dom元素的innerHTML属性值 return this[0] ? this[0].innerHTML : ''; &#125; else &#123; // 如果给html传值。给moyas对象上每一个dom元素设置innerHTML属性 return this.each(function(v) &#123; v.innerHTML = html; &#125;); &#125; &#125;, text: function(text) &#123; // 如果没有传值，表示获取文本值 if (text == undefined) &#123; // 定义结果变量，存储每个dom元素的文本 var ret = ''; // 遍历每一个dom元素 this.each(function(v) &#123; // 如果支持textContent，使用其获取文本，累加到ret上 ret += 'textContent' in document ? v.textContent : v.innerText.replace(/\r\n/g, ''); &#125;); // 返回所有文本 return ret; &#125; else &#123; // 如果传值了，表示为每个dom设置文本 return this.each(function(v) &#123; // 如果支持textContent，就使用该属性为当前dom元素设置文本节点值 // 否则，使用innerText设置文本节点值。 if ('textContent' in document) &#123; v.textContent = text; &#125; else &#123; v.innerText = text; &#125; &#125;); &#125; &#125;, val: function(value) &#123; // 如果没有传值，表示获取第一个dom元素的value属性值 // 如果moyas对象上没有任何dom元素，返回空字符串 if (value == undefined) &#123; return this[0] ? this[0].value : ''; &#125; else &#123; // 否则，为每一个dom元素设置value属性值 return this.each(function() &#123; this.value = value; &#125;); &#125; &#125;, prop: function(name, value) &#123; // 如果没有给value传值 var prop; if (value == undefined) &#123; // 并且name的类型为 对象，表示给每一个dom对象添加多个属性 if (typeof name === 'object') &#123; this.each(function() &#123; for (var k in name) &#123; // 首先从propFix对象上获取属性名字 // 如果有，就使用新的属性名字 // 如果没有，就使用原来的属性名字 prop = moyas.propFix[k] ? moyas.propFix[k] : k; this[prop] = name[k]; &#125; &#125;); &#125; else &#123; // 如果name的类型 为字符串，表示获取第一个dom对象的指定属性值 prop = moyas.propFix[name] ? moyas.propFix[name]: name; return this.length &gt; 0 ? this[0][prop] : null; &#125; &#125; else &#123; // 如果传入两个参数，表示给每一个dom对象添加单个属性 // 遍历moyas上的每一个dom对象，添加属性 prop = moyas.propFix[name] ? moyas.propFix[name]: name; this.each(function() &#123; this[prop] = value; &#125;); &#125; // 实现链式编程 return this; &#125; &#125;);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[js异常处理]]></title>
      <url>%2F2016%2F11%2F20%2Fjs%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%2F</url>
      <content type="text"><![CDATA[#异常处理 ##常见的异常分类 运行环境的多样性导致的异常（浏览器） 语法错误，代码错误 异常最大的特征，就是一旦代码出现异常，后面的代码就不会再执行 ##异常捕获 捕获异常，使用try-catch语句123456try&#123; //这里写可能出现异常的代码&#125;catch(e)&#123; //这里的e就是捕获的异常对象 //可以在这里写，出现异常后的处理代码&#125; 异常捕获语句执行的过程为： 代码正常运行, 如果在try中出现了错误, try 里面出现错误的语句后面的代码都不再执行, 直接跳转到 catch 中 catch中处理错误信息 然后继续执行后面的代码 如果 try 中没有出现错误, 那么不走 catch 直接执行后面的代码 通过try-catch语句进行异常捕获之后，代码将会继续执行，而不会中断。 注意： 语法错误异常用try-catch语句无法捕获，因为在预解析阶段，语法错误会直接检测出来，而不会等到运行的时候才报错。 try-catch在一般日常开发中基本用不到，但是如果要写框架什么的，用的会非常多。因为这个会让框架变得健壮 ##抛出异常 如何手动的抛出异常呢？ 案例：自己写的一个函数，需要一个参数，如果用户不传参数，此时想直接给用户抛出异常，就需要了解如何抛出异常。 抛出异常使用throw关键字，语法如下：1throw 异常对象; 异常对象一般是用new Error(&quot;异常消息&quot;), 也可以使用任意对象 12345678910111213function test(para)&#123; if(para == undefined)&#123; throw new Error("请传递参数"); //这里也可以使用自定义的对象 throw &#123;"id":1, msg:"参数未传递"&#125;; &#125;&#125;try&#123; test();&#125;catch(e)&#123; console.log(e);&#125; ##异常的传递机制 123456789101112function f1 () &#123; f2(); // f1 称为调用者, 或主调函数, f2 称为被调用者, 或被调函数&#125;function f2 () &#123; f3();&#125;function f3() &#123; throw new Error( 'error' );&#125;f1(); 当在被调函数内发生异常的时候，异常会一级一级往上抛出。 ##异常捕获语句的完整模式 异常捕获语句的完整模式为try-catch-finally 1234567try &#123; //可能出现错误的代码&#125; catch ( e ) &#123; //如果出现错误就执行&#125; finally &#123; //结束 try 这个代码块之前执行, 即最后执行&#125; finally中的代码，不管有没有发生异常，都会执行。一般用在后端语言中，用来释放资源，JavaScript中很少会用到]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[javascript原生框架(八)--ajax异步请求和jsonp跨域]]></title>
      <url>%2F2016%2F11%2F19%2Fjs%E5%8E%9F%E7%94%9F%E6%A1%86%E6%9E%B6-ajax-jsonp%2F</url>
      <content type="text"><![CDATA[Ajax请求流程 创建一个请求对象 格式化数据 将格式化后的数据，参数与值都要重新编码 与服务器建立连接 监听请求状态 发送请求 Jsonp请求 跨域 只能发送 GET请求。一种不安全的请求方式。 原理：由于dom元素的 src属性 具有跨域功能。在实现跨域请求时，为了方便就使用script标签来做。 流程 创建请求对象，就是 创建一个script标签 将上述创建的script标签添加到页面的head标签下 格式化数据 创建全局回调函数 设置超时时间，如果超过此时间，也没有得到数据，表示请求失败。否则，请求成功。 删除 发送请求：指定script标签的src属性值。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165//ajax 模块 moyas.extend(&#123; ajaxSetting: &#123; url: '', type: 'GET', dataType: 'text', contentType: 'application/x-www-form-urlencoded', jsonp: 'callback', jsonpCallback: '', data: null, async: true, success: null, fail: null, timeout: 0 &#125;, ajax: function(config) &#123; //过滤无效的参数 if (!config || !config.url) &#123; console.warn("参数异常"); return; &#125; if (config.dataType.toLowerCase() === 'jsonp') &#123; jsonp(config); &#125; else &#123; ajax(config); &#125; &#125; &#125;); function jsonp(config) &#123; var scriptElem, headElem, context = &#123;&#125;, callbackName; //过滤无效的参数 if (!config || !config.url) &#123; console.warn('参数异常'); return; &#125;; moyas.extend(moyas.ajaxSetting, context); moyas.extend(config, context); //1 创建对象 scriptElem = document.createElement('script'); //2 将创建的script标签添加到页面的head下 headElem = document.getElementsByTagName('head')[0]; headElem.appendChild(scriptElem); //3 格式化数据 context.url += '?' + formatData(context.data); //4 创建全局回调函数的名字 callbackName = context.jsonpCallback ? context.jsonpCallback : 'jsonp_' + (+new Date); //把全局回调函数的名字发给服务器 context.url += '&amp;' + context.jsonp + '=' + callbackName; window[callbackName] = function(data) &#123; //请求成功 //删除动态创建的script 标签 headElem.removeChild(scriptElem); //删除全局回调函数 delete window[callbackName]; //清除超时的延迟函数 window.clearTimeout(scriptElem.timer); //执行用户指定的成功的回调函数 context.success &amp;&amp; context.success(data); &#125;; //设置超时时间 if (context.timeout) &#123; scriptElem.timer = window.setTimeout(function() &#123; //请求失败 //删除动态创建的script标签 headElem.removeChild(scriptElem); //删除全局回调函数 delete window[callbackName]; //执行用户指定的失败的回调函数 context.fail &amp;&amp; context.fail(&#123; 'message': '请求超时' &#125;); &#125;, context.timeout); &#125; //发送请求 scriptElem.src = context.url; &#125; function createRequest() &#123; return window.XMLHttpRequest ? new window.XMLHttpRequest() : new ActiveXObject('Microsoft.XMLHTTP'); &#125; function formatData(data) &#123; var ret = []; for (var k in data) &#123; ret.push(window.encodeURIComponent(k) + '=' + window.encodeURIComponent(data[k])); &#125; //如果不想从服务器缓存中读取数据 ret.push(('_=' + Math.random()).replace('.', '')); return ret.join('&amp;'); &#125; function ajax(config) &#123; var context = &#123;&#125;, xhr, postData = ''; //过滤无效的参数 if (!config || !config.url) &#123; consloe.warn('参数异常'); return; &#125; //获取默认配置信息 moyas.extend(moyas.ajaxSetting, context); //用户配置信息 覆盖默认配置 moyas.extend(config, context); //1 创建请求对象 xhr = createRequest(); //2 格式话数据 if (context.data) &#123; postData = formatData(context.data); &#125; //3 与服务器建立链接 if (context.type.toUpperCase() === 'GET') &#123; xhr.open('GET', context.url + '?' + postData, context.async); postData = null; &#125; else &#123; //模拟表单提交 设置请求头信息 xhr.setRequestHeader('content-Type', context.contentType); xhr.open('OPST', context.url, contex.async); &#125; //监听请求状态 xhr.onreadystatechange = function() &#123; if (xhr.readyState === 4) &#123; if (xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300 || xhr.status === 304)&#123; //获取到请求回来的数据 var text = xhr.responseText; //如果指定的数据格式为 json 那么就将其转换成json 对象 text = context.dataType.toLowerCase() === 'json'?JSON.parse(text) : text; context.success &amp;&amp; context.success(text); &#125; else &#123; context.fail &amp;&amp; context.fail(&#123; "errorCode": xhr.status, "massage": "请求超时" &#125;); &#125; &#125; &#125;; //发送请求 xhr.send(postData); &#125; jQuery框架就介绍到这里了 前面封装的整体代码 github 地址:https://github.com/moyas/Tutorial/tree/master/my-jQuery 点击链接]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[javascript原生框架(三)--css样式模块的封装]]></title>
      <url>%2F2016%2F11%2F19%2Fjs%E5%8E%9F%E7%94%9F%E6%A1%86%E6%9E%B6-css%E6%A0%B7%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[css样式模块的封装 each方法的实现 1.在写样式之前,先给核心函数添加一个each方法. -实现的代码如下123456789moyas.extend(&#123;each: function (obj, callback) &#123; var i = 0, l = obj.length; for (; i &lt; l; i++) &#123; if (callback.call(obj[i], obj[i], i) === false) break; &#125; &#125;&#125;) 2.写一个用于css样式的each 方法,用于实现链式编程-代码12345678910moyas.fn.extend(&#123; //提供给moyas对象调用 //遍历this each:function (callback) &#123; moyas.each(this,callback); //实现链式编程 //放回方法的调用者 return this; &#125; &#125;); css样式方法 获取设置样式-css(); 判断类名-hasClass(); 添加类名-addClass(); 移除类名-removeClass(); *切换类名-toggleClass(); 代码如下1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677moyas.fn.extend(&#123; //判断有没有这个类名 hasClass:function (className) &#123; //默认的结果为flase; var ret = false; //遍历this 上的每一个dom 元素 this.each(function (v) &#123; if ((" "+v.className+" ").indexOf(" "+className+" ")!==-1)&#123; ret = true; return false; &#125; &#125;); return ret; &#125;, //添加类名 addClass:function (className) &#123; return this.each(function (v) &#123; if(!moyas(v).hasClass(className))&#123; v.className += " "+className; &#125; &#125;); &#125;, //移除类名 removeClass:function (className) &#123; return this.each(function (v) &#123; v.className = (" "+v.className+" ").replace(" "+ calssName + " "," "); &#125;); &#125;, //切换类名 toggleClass:function (className) &#123; return this.each(function (v) &#123; var $v = moyas(v); if ($v.hasClass(className))&#123; $v.removeClass(className); &#125;else &#123; $v.addClass(className); &#125; &#125;); &#125;, //css样式的获取和设置 //判断传入的参数 //如果有对应的值 则为设置样式 //如果没有对应的值 则为获取样式 css:function (name,value) &#123; //至传入一个参数 if(value==undefined)&#123; //如果name类型为对象 则同时设置多个值 if (typeof name ==='object')&#123; //遍历设置 this.each(function (v) &#123; for(var k in name)&#123; v.style[k]=name[k]; &#125; &#125;); &#125;else &#123; //如果name 不为对象 //默认获取this 上的第一个dom 元素的指定的样式 //先判断 如果this上没有任何的dom 元素 则返回null if(!this[0]) return null; return window.getComputedStyle?window.getComputedStyle(this[0])[name] : this[0].currentStyle[name]; &#125; &#125;else &#123; //传入两个参数 this.each(function (v) &#123; v.style[name]=value; &#125;); &#125; //实现链式编程 return this; &#125;&#125;);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[javascript原生框架(二)--init构造函数的完善]]></title>
      <url>%2F2016%2F11%2F19%2Fjs%E5%8E%9F%E7%94%9F%E6%A1%86%E6%9E%B6-init%E5%87%BD%E6%95%B0%2F</url>
      <content type="text"><![CDATA[完善init构造函数+ selector类型： - 无效值： null undefined &apos;&apos; false - 字符串 * 选择器： &apos;div&apos; 根据选择器筛选dom元素，并以伪数组形式 存储在this上 * html字符串 &apos;&lt;p&gt;123&lt;/p&gt;&lt;p&gt;456&lt;/p&gt;&apos; &apos;&lt;p&gt;&apos; 将html字符串 转换成 html元素 - DOM节点 - DOM数组（伪数组） - function：入口函数 DOMContentLoaded * 使用静态属性isReady 存储 dom树是否加载完毕 * 判断isReady值， 如果为true，就直接执行传入的函数。 * 否则，就给document的DOMContentLoaded事件绑定处理程序，在处理程序中，先将isReady赋值为true，在执行传入的函数。 如何判断字符串为html字符串，必须满足一下条件： 以’&lt;’开头 以’&gt;’结尾 最小长度为3 如何判断像数组（数组和伪数组） 用length属性去判断，若具有length属性 表示为 像数组类型 除了window对象以及函数对象 {length: 1} {4: “123”, length: 5} 稀疏数组 如果为真数组，返回true 如果length属性值为0（除了window对象以及函数对象），返回true 如果length属性值&gt;0, 如果对象 具有 length - 1 索引，返回true 全局对象 window特性：有一个window属性 引用 自身。 代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120(function(global) &#123; var init, document = global.document; var moyas = function(selector) &#123; return new moyas.fn.init(selector); &#125;; moyas.fn = moyas.prototype = &#123; constructor: moyas, length: 0 &#125;; init = moyas.fn.init = function(selector) &#123; // handle: null undefined '' false if(!selector) return this; // handle: string else if(moyas.isString(selector))&#123; // handle: html string '&lt;p&gt;123&lt;/p&gt;' if(moyas.isHTML(selector))&#123; // 怎么存储 以伪数组对象形式存储 dom元素 Array.prototype.push.apply(this, moyas.parseHTML(selector)); &#125; // handle: selector else &#123; // 根据选择器获取dom元素 var nodelist = document.querySelectorAll(selector); // 将结果伪数组对象 变成 真数组 var ret = Array.prototype.slice.call(nodelist); // 借调数组对象的slice方法将数组中的所有元素 以伪数组形式存储在this上 Array.prototype.push.apply(this, ret); &#125; &#125; // handle: dom node else if(moyas.isDOM(selector))&#123; this[0] = selector; this.length = 1; &#125; // handle: dom array(伪数组对象) else if(moyas.isArrayLike(selector))&#123; // 获取selector类型 var _type = Object.prototype.toString.call(selector). slice(8, -1).toLowerCase(); // 如果不是数组类型,就 将其转换 为 真数组类型 if(_type !== 'array') selector = Array.prototype.slice.call(selector); Array.prototype.push.apply(this, selector); &#125; // handle: function else if(moyas.isFunction(selector))&#123; if(moyas.isReady)&#123; selector(); &#125; else &#123; doucment.addEventListener('DOMContentLoaded', function() &#123; selector(); moyas.isReady = true; &#125;); &#125; &#125; &#125;; init.prototype = moyas.fn; moyas.extend = moyas.fn.extend = function(source, target) &#123; var k; target = target || this; for(k in source)&#123; target[k] = source[k]; &#125; &#125;; // 添加工具类方法 moyas.extend(&#123; isReady: false, paseHTML: function(html) &#123; var div = document.createElement('div'), ret = []; div.innerHTML = html; for(var elem = div.firstChild; elem; elem = elem.nextSibling)&#123; if(elem.nodeType === 1) ret.push(elem); &#125; return ret; &#125; &#125;); // 类型判断方法 moyas.extend(&#123; // 判断是否为字符串类型 isString: function(obj) &#123; // 如果为null或undefined，返回false // 如果typeof值为string，返回true否则返回false。 return !!obj &amp;&amp; typeof obj === 'string'; &#125;, isHTML: function(obj) &#123; return !!obj &amp;&amp; obj.charAt(0) === '&lt;' &amp;&amp; obj.charAt(obj.length - 1) === '&gt;' &amp;&amp; obj.length &gt;= 3; &#125;, isDOM: function(obj) &#123; return !!obj &amp;&amp; !!obj.nodeType; &#125;, isFunction: function(obj) &#123; return !!obj &amp;&amp; typeof obj === 'function'; &#125;, isGlobal: function(obj) &#123; return !!obj &amp;&amp; obj.window === obj; &#125;, isArrayLike: function(obj) &#123; var _type = Object.prototype.toString.call(obj).slice(8, -1).toLowerCase(), length = !!obj &amp;&amp; 'length' in obj &amp;&amp; obj.length; // 过滤 window对象和函数对象 if(moyas.isFunction(obj) || moyas.isGlobal(obj)) return false; return _type === 'array' || length === 0 || typeof length === 'number' &amp;&amp; length &gt; 0 &amp;&amp; (length - 1) in obj; &#125; &#125;); global.$ = global.moyas = moyas; &#125;(window));]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[javascript原生框架(一)--jq框架详解]]></title>
      <url>%2F2016%2F11%2F18%2Fjs%E5%8E%9F%E7%94%9F%E6%A1%86%E6%9E%B6-%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6%2F</url>
      <content type="text"><![CDATA[框架结构说明 在编写框架的时候，为了防止变量污染，尽量使用沙箱模式 封装框架 在沙箱内部，如果经常使用全局变量或全局对象的话，最好的做法就是将它们当做实参传入沙箱内。 核心函数为moyas，相当于jQuery。最终要暴露给用户使用的 实现moyas函数，使用的是 工厂模式 来 创建对象。好处：用户 new 或 不 new 都可以得到正确的对象 init构造函数 的 位置 如果放在沙箱内部，用户是无法修改或重写的。所以要容纳更改用户，尽量将构造函数暴露给用户 可以把构造函数放在moyas函数上，也可以放在moyas函数原型上。 处于jQuery之父，在写简单继承模式时，将构造函数放在其原型上。那么在编写框架时，即延续下来了 init创建出来的对象，最终继承自moyas.prototype。所以可以将init对象称为 moyas对象。 由于暴露给用户 的 是 moyas 和 其原型。所以在扩展成员时，只能在这两个对象上扩展。 而在函数对象上扩展的成员 为 静态成员。可以直接通过函数名字来访问。但是，在原型上的成员， 必须创建实例来访问。因此为了实现init对象可以访问 moyas原型上的成员，就基于原型来实现继承。 12345678910111213141516171819202122232425262728293031323334353637(function(global) &#123; var init; // 核心函数（工厂函数） var moyas = function(selector) &#123; return new moyas.fn.init(selector); &#125;; // 核心原型 moyas.fn = moyas.prototype = &#123; constructor: moyas &#125;; // 构造函数 init = moyas.fn.init = function(selector) &#123;&#125;; // 实现init对象继承自moyas原型 init.prototype = moyas.fn; // 可扩展方法 // 如果target为undefined值，那么就是给this扩展成员 // 否则就是给target对象扩展。 moyas.extend = moyas.fn.extend = function(source, target) &#123; var k; // 如果target为undefined值，就赋值为this // 给this扩展成员 if (target == undefined) &#123; target = this; &#125; // target = target || this; for(k in source)&#123; target[k] = source[k]; &#125; &#125;; // 暴露给用户 global.$ = global.moyas = moyas;&#125;(window));]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[元素获取所有子节点]]></title>
      <url>%2F2016%2F11%2F17%2F%E5%85%83%E7%B4%A0%E8%8E%B7%E5%8F%96%E6%89%80%E6%9C%89%E5%AD%90%E8%8A%82%E7%82%B9%2F</url>
      <content type="text"><![CDATA[使用原生javascript获取元素的所有元素子节点的方法详细介绍 1利用childrenNodes的方法12345678910111213141516171819202122232425// 实现思路：// 通过childNodes获取到所有的子节点；// 将上述所有的子节点中，元素节点获取出来。/** * [getChildren 获取子元素] * @param &#123;[type]&#125; parent [父节点] * @return &#123;[type]&#125; [返回parent的所有子元素] */function getChildren(parent) &#123; // 存储结果集 var ret = [], nodes; // 获取parent所有子节点 nodes = parent.childNodes; // 遍历nodes for(var i = 0,l = nodes.length; i &lt; l;i++)&#123; // 如果遍历到当前子节点类型为元素，即为所要结果。存储在ret内。 if(nodes[i].nodeType === 1) &#123; ret.push(nodes[i]); &#125; &#125; // 返回结果 return ret;&#125; 2利用firstChild和nextSibling方法实现(推荐)-比起childNodes可以减少一些性能问题,jquery中使用的也是这种方法.12345678910111213141516function getChildren(parent) &#123; var ret = [], elem = parent.firstChild; // 遍历parent所有子节点 // 如果有子节点 while(elem)&#123; // 并且节点类型为元素。存储在ret内 if(elem.nodeType === 1) ret.push(elem); // 更新循环标量 // 赋值为下一个兄弟节点 elem = elem.nextSibling; &#125; // 返回结果 return ret; &#125; 3也可以将第二种方法中的while循环改成for循环12345678910function getChildren(parent) &#123; var ret = [], elem = parent.firstChild; for(; elem ; elem = elem.nextSibling)&#123; if(elem.nodeType === 1) ret.push(elem); &#125; return ret; &#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[javascript继承的实现方式]]></title>
      <url>%2F2016%2F11%2F10%2Fjavascript%E7%BB%A7%E6%89%BF%2F</url>
      <content type="text"><![CDATA[继承的实现方式混入式继承（mix-in）12345var obj = &#123;&#125;;var obj1 = &#123;name:"adsf",age:18&#125;;for(var k in obj1)&#123; obj[k] = obj1[k];&#125; 原型继承1.使用混入的方式为原型对象添加成员、123456var human = &#123;name:"",age:18&#125;function Person()&#123;&#125;;for(var k in human)&#123; Person.prototype[k] = human[k];&#125; 2.直接修改原型对象123function Person()&#123;&#125;Person.prototype.name = "";Person.prototype.age = 18; 3.替换原型对象123var human = &#123;name:"",age:18&#125;function Person()&#123;&#125;;Person.prototype = human; 经典继承123var obj = Object.create(obj1);//创建出来一个新的对象obj继承自obj1//原理就是把obj1设置为obj的原型 经典继承的兼容性问题1234567891011function myCreate(obj)&#123; //判断浏览器有没有Object.create方法 if(Object.create)&#123; //如果有，直接调用 return Object.create(obj); &#125;else&#123; function F()&#123;&#125; F.prototype = obj; return new F(); &#125;&#125; 为什么不能修改原生对象?因为原生对象是公用的，在多人开发的时候，可能会出现冲突，你修改了，他也修改了，谁的生效呢？]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>%2F2016%2F11%2F07%2Fhello-world%2F</url>
      <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
    </entry>

    
  
  
</search>
